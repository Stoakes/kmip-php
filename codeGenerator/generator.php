<?php

require __DIR__.'/../vendor/autoload.php';
function main($argc, $argv)
{
    $options = getopt("i:o:h", ["input:", "output:", "help"]);

    if (isset($options['h']) || isset($options['help'])) {
        printUsage();
        exit(0);
    }

    $inputFilename = $options['i'] ?? $options['input'] ?? '';
    $outputFolder = $options['o'] ?? $options['output'] ?? '';
    // Check if path is absolute
    if (!(substr($outputFolder, 0, 1) === '/')) {
        // Resolve relative path from current working directory
        $outputFolder = realpath(getcwd().'/'.$outputFolder);
    }

    if (empty($inputFilename)) {
        echo "Input file name cannot be empty\n";
        printUsage();
        exit(1);
    }

    try {
        run($inputFilename, $outputFolder);
    } catch (Exception $e) {
        echo $e->getMessage()."\n";
        exit(1);
    }
}

function printUsage()
{
    echo "Usage of kmipgen:\n\n";
    echo "Generates PHP code which registers tags, enumeration values, and mask values.\n";
    echo "Specifications are defined in a JSON file.\n\n";
    echo "Options:\n";
    echo "  -i, --input    Input filename of specifications. Required.\n";
    echo "  -o, --output   Output folder. Defaults to standard out.\n";
    echo "  -h, --help     Show this usage message.\n";
}

function run($inFilename, $outFolder)
{
    $inputContent = file_get_contents($inFilename);
    if ($inputContent === false) {
        throw new Exception("Error reading input file: $inFilename");
    }

    $specs = json_decode($inputContent, true);
    if (json_last_error() !== JSON_ERROR_NONE) {
        throw new Exception("Error decoding JSON: ".json_last_error_msg());
    }

    $in = prepareInput($specs);

    /* Enums generation */
    if(!is_dir($outFolder.'/Enum/')) {
        mkdir($outFolder.'/Enum/');
    }
    foreach ($in['enums'] as $e) {
        $file = generateEnumMaskFile('Enum', $e);
        file_put_contents(
            $outFolder.'/Enum/'.$e['typeName'].'.php',
            (new Nette\PhpGenerator\PsrPrinter)->printFile($file)
        );
    }

    /* Masks generation */
    if(!is_dir($outFolder.'/Mask/')) {
        mkdir($outFolder.'/Mask/');
    }
    foreach ($in['masks'] as $e) {
        $file = generateEnumMaskFile('Mask', $e);

        file_put_contents(
            $outFolder.'/Mask/'.$e['typeName'].'.php',
            (new Nette\PhpGenerator\PsrPrinter)->printFile($file)
        );
    }

    /* Tags generation */
    if(!is_dir($outFolder.'/Tag/')) {
        mkdir($outFolder.'/Tag/');
    }
    $file = generateTagFile($in['tags']);
    file_put_contents($outFolder.'/Tag/Tag.php', (new Nette\PhpGenerator\PsrPrinter)->printFile($file));

}

function parseUint32($v)
{
    if (is_string($v)) {
        if (strpos($v, '0x') === 0) {
            return hexdec(substr($v, 2));
        }

        return intval($v);
    } elseif (is_numeric($v)) {
        return intval($v);
    }
    throw new Exception("Value must be a number, or a hex string, like 0x42015E");
}

function prepareInput($specs)
{
    $in = [
        'tags' => [],
        'enums' => [],
        'masks' => [],
    ];

    // Prepare tags
    foreach ($specs['tags'] as $key => $value) {
        $in['tags'][] = [
            'fullName' => $key,
            'name' => normalizeName($key),
            'value' => parseUint32($value),
        ];
    }

    usort($in['tags'], function ($a, $b) {
        return $a['value'] <=> $b['value'];
    });

    // Prepare enums and masks
    foreach (['enums', 'masks'] as $type) {
        foreach ($specs[$type] as $enumDef) {
            $ev = [
                'name' => $enumDef['name'],
                'comment' => $enumDef['comment'] ?? '',
                'typeName' => normalizeName($enumDef['name']),
                'vals' => [],
                'tags' => array_map('normalizeName', $enumDef['tags']),
                'bitMask' => ($type === 'masks'),
            ];

            foreach ($enumDef['values'] as $key => $value) {
                $ev['vals'][] = [
                    'fullName' => $key,
                    'name' => normalizeName($key),
                    'value' => parseUint32($value),
                ];
            }

            usort($ev['vals'], function ($a, $b) {
                return $a['value'] <=> $b['value'];
            });

            $in[$type][] = $ev;
        }
    }

    return $in;
}


function generateEnumMaskFile(string $folder, array $data): \Nette\PhpGenerator\PhpFile
{
    $file = new Nette\PhpGenerator\PhpFile;
    $file->addComment('DO NOT EDIT. This file is auto-generated by stoakes/kmip-php code generator');
    $file->setStrictTypes(); // adds declare(strict_types=1)
    $namespace = $file->addNamespace('Stoakes\Kmip\\'.$folder); // assumes Enums folder already exists
    $enum = $namespace->addEnum($data['typeName']);

    $enum->setType('int');
    $valueToCanonicalNameMethod = $enum->addMethod('valueToCanonicalName')
        ->setReturnType('string')
        ->setPublic();
    $valueToCanonicalNameMethod->addParameter('value')
        ->setType('self');

    $valueToCanonicalNameMethodBody = 'return match($value)'."\n{\n";
    foreach ($data['vals'] as $val) {
        $enum->addCase($val['name'], $val['value'])
            ->addComment(sprintf("0x%08X", $val['value']));
        $valueToCanonicalNameMethodBody .= '    self::'.$val['name'].' => \''.$val['fullName']."',\n";
    }
    if (!$data['vals'] || count($data['vals']) == 0) { // if no values, return '', so that function is still valid
        $valueToCanonicalNameMethodBody .= 'default => \'\',';
    }
    $valueToCanonicalNameMethodBody .= "};";
    $valueToCanonicalNameMethod->addBody($valueToCanonicalNameMethodBody);

    $enum->addMethod('canonicalName')
        ->setReturnType('string')
        ->setPublic()
        ->addBody('return self::valueToCanonicalName($this);');

    return $file;
}

function generateTagFile(array $data): \Nette\PhpGenerator\PhpFile
{
    $file = new Nette\PhpGenerator\PhpFile;
    $file->addComment('DO NOT EDIT. This file is auto-generated by stoakes/kmip-php code generator');
    $file->setStrictTypes(); // adds declare(strict_types=1)
    $namespace = $file->addNamespace('Stoakes\Kmip\\Tag'); // assumes Enums folder already exists
    $enum = $namespace->addEnum('Tag');

    $enum->setType('int');
    $valueToCanonicalNameMethod = $enum->addMethod('valueToCanonicalName')
        ->setReturnType('string')
        ->setPublic();
    $valueToCanonicalNameMethod->addParameter('value')
        ->setType('self');

    $valueToCanonicalNameMethodBody = 'return match($value)'."\n{\n";
    foreach ($data as $val) {
        $enum->addCase($val['name'], $val['value'])
            ->addComment(sprintf("0x%08X", $val['value']));
        $valueToCanonicalNameMethodBody .= '    self::'.$val['name'].' => \''.$val['fullName']."',\n";
    }

    $valueToCanonicalNameMethodBody .= "};";
    $valueToCanonicalNameMethod->addBody($valueToCanonicalNameMethodBody);

    $enum->addMethod('canonicalName')
        ->setReturnType('string')
        ->setPublic()
        ->addBody('return self::valueToCanonicalName($this);');

    $normalizeName = $enum->addMethod('normalizeName')
        ->setReturnType('string')
        ->setStatic()
        ->setPrivate()
        ->addBody(
            'return preg_replace(\'/^([\d]+)(.*)/\', \'$2$1\',
            strtr(
                ucwords($name),
                ["." => "_", "#" => "_", " " => "", "/" => "", "-" => "", "^" => "_", "(" => "", ")" => ""]
            )
        );'
        );
    $normalizeName->addParameter('name')->setType('string');

    $fromNameMethod = $enum->addMethod('fromName')
        ->setReturnType('\Stoakes\Kmip\Tag\Tag')
        ->setStatic()
        ->setPublic()
        ->addBody(
            '$normalizedName = self::normalizeName($name);

return constant(\'self::\'.$normalizedName);'
        );
    $fromNameMethod->addParameter('name')->setType('string');

    $hasNameMethod = $enum->addMethod('hasName')
        ->setReturnType('bool')
        ->setStatic()
        ->setPublic()
        ->addBody(
            '$normalizedName = self::normalizeName($name);

return defined( \'self::\' . $normalizedName);'
        );
    $hasNameMethod->addParameter('name')->setType('string');

    return $file;
}

/** transform KMIP name into PHP valid constants name.
 * 1. Capitalize every word
 * 2. Replace invalid characters (such as #(/ ) by _ or ''
 * 3. If string starts with a number, put it at the end
 */
function normalizeName($name)
{

    return preg_replace(
        '/^([\d]+)(.*)/',
        '$2$1',
        strtr(
            ucwords($name),
            ['.' => '_', '#' => '_', ' ' => '', '/' => '', '-' => '', '^' => '_', '(' => '', ')' => '']
        )
    );
}

// Run the script
main($argc, $argv);
